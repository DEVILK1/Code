# 最大公约数：

求证：gcd(a, b) = gcd(b, a % b) 当且仅当 a > b > 0

**证明：**

```c++
设:
 gcd(a, b) = k
 a = kc, b = kd（c∈N*, d∈N*）
 ∴c、d互质（c、d的公约数只有1）且c > d
 ∴a - b = k(c - d)
 ∴gcd(b, a - b) = gcd(kd, k(c - d))
       
    假设 d、(c - d)不互质
    即 d|(c - d)
    ∴设c - d = k'd
    ∴c = d(k' + 1)
    与题设“c、d互质”不符，
    ∴d与(c - d)互质
       
 ∴gcd(kd, k(c - d)) = k
 ∴gcd(a, b) = gcd(b, a - b)
 ∴gcd(a, b) = gcd(b, a % b)
```

**程序实现：**
```c++
int gcd(int a, int b) {
	return b == 0 ? a : gcd(b, a % b);
}
```

# 扩展欧几里得：

求一组x、y，使得ax + by = gcd(a, b).

**求解：**
```c++
ax + by = gcd(a, b)
	= gcd(b, a % b)
	= bx' + (a % b)y'
	= bx' + (a - [a / b] * b)y'
	= bx' + ay' - [a / b] * by'
	= ay' + b(x' - [a / b]y')
	
∴x = y', y = x' - [a / b] * y'

终止条件：
b = 0时：a * 1 + b * 0 = a
即x = 1, y = 0
递归求解
```

**程序实现：**
```c++
int ex_gcd(int a, int b, int &x, int &y) {
	if(b == 0) {
		x = 1, y = 0;
		return a;
	}
	int g = ex_gcd(b, a % b, y, x);
	//递归后的x相当于y', y相当于x'
	y -= a / b * x;
	return g;
}
```
